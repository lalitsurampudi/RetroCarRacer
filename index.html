<!-- This first line tells the computer that this is an HTML5 webpage. It's like the title page of a book! -->
<!DOCTYPE html>
<!-- This is the main HTML tag that holds our entire website. Everything goes inside this! -->
<html lang="en">
<!-- The <head> is like the brain of our webpage. It holds important settings and links, but you don't see it on the page itself. -->

<head>
    <!-- This line makes sure all our text and emojis show up correctly. -->
    <meta charset="UTF-8">
    <!-- This line tells phones and tablets how to show our game so it fits the screen perfectly. -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- This is the title that you see in the browser tab at the very top. -->
    <title>90s Retro Car Racer - Kid-Friendly Comments</title>

    <!-- These next two lines are like borrowing cool tools from the internet. -->
    <!-- This one gets a bunch of pre-made style rules called Tailwind CSS to make our buttons and text look nice quickly. -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- This one gets the cool, blocky pixel font for our game from Google Fonts. -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <!-- The <style> tag is where we write our own CSS rules to design our page. -->
    <style>
        /* This rule makes the whole page have a dark background and uses our cool pixel font. */
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a1a;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        /* This styles the black box that our game will be inside. */
        #gameContainer {
            background-color: #000;
            border: 5px solid #555;
            border-radius: 10px;
            box-shadow: 0 0 25px rgba(0, 255, 0, 0.4);
            position: relative;
            overflow: hidden;
        }

        /* This is for the actual game screen where we will draw everything. */
        canvas {
            display: block;
            background-color: #4a4a4a;
            /* Road color */
            border-radius: 5px;
        }

        /* This is a container for all the text at the top, like the score. */
        .game-ui {
            padding: 10px;
            text-align: center;
            width: 100%;
            max-width: 600px;
        }

        /* A box to hold our start button. */
        .button-container {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        /* This styles all the buttons to look like retro game buttons. */
        .game-button {
            background-color: #00A0A0;
            color: #fff;
            border: 2px solid #00FFFF;
            padding: 10px 15px;
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            cursor: pointer;
            border-radius: 5px;
            box-shadow: 0 4px #006060;
            transition: all 0.1s ease;
        }

        /* This makes the button look like it's being pushed down when you click it. */
        .game-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px #006060;
        }

        /* This is the box that pops up when the game is over. */
        #gameOverMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            padding: 30px;
            border-radius: 10px;
            border: 3px solid #ff0000;
            text-align: center;
            z-index: 10;
            box-shadow: 0 0 15px #ff0000;
        }

        /* This is the box that holds the touch controls for phones. */
        #touchControls {
            display: none;
            /* It starts off hidden! */
            justify-content: space-around;
            width: 100%;
            max-width: 400px;
            margin-top: 10px;
        }

        /* This styles the buttons for touch screens. */
        .touch-button {
            background-color: #d9534f;
            color: #fff;
            border: 2px solid #c9302c;
            padding: 12px 18px;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            cursor: pointer;
            border-radius: 8px;
            box-shadow: 0 4px #b52b27;
            user-select: none;
        }

        .touch-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px #b52b27;
        }

        /* This is the box that holds our Gemini Announcer's text! */
        #announcerBox {
            margin-top: 10px;
            padding: 8px;
            background-color: #2a2a2a;
            border: 2px solid #ff00ff;
            border-radius: 5px;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* This styles the announcer's text color and size. */
        #announcerText {
            color: #00FFFF;
            /* Cyan text */
            font-size: 0.9em;
        }

        /* This is a special rule for smaller screens, like phones. */
        @media (max-width: 700px) {

            /* It makes buttons and text a bit smaller on small screens. */
            .game-button {
                font-size: 12px;
                padding: 8px 12px;
            }

            /* And it makes the touch controls appear! */
            #touchControls {
                display: flex;
            }
        }
    </style>
</head>

<!-- The <body> is where all the visible stuff on the page goes, like our game title, score, and the game itself. -->

<body>
    <!-- This is a "div", which is like a box or container. This one holds all the text at the top. -->
    <div class="game-ui">
        <!-- <h1> is a big, important title. -->
        <h1 class="text-3xl sm:text-4xl mb-2 text-green-400" style="text-shadow: 2px 2px #ff00ff;">Retro Car Racer</h1>
        <!-- These divs show the current score and the high score. -->
        <div id="scoreBoard" class="text-xl sm:text-2xl">Score: <span id="score">0</span></div>
        <div id="highScoreBoard" class="text-lg sm:text-xl mb-1">High Score: <span id="highScore">0</span></div>
        <!-- This is the announcer's box! The text inside will be changed by our JavaScript. -->
        <div id="announcerBox">
            <span id="announcerText">Press Start to Race!</span>
        </div>
    </div>

    <!-- This box holds our game screen and the "Game Over" message that can pop up on top of it. -->
    <div id="gameContainer">
        <!-- THIS IS THE MOST IMPORTANT PART! The <canvas> is like a blank piece of paper. -->
        <!-- All our JavaScript code will draw the road, cars, and signs right here! -->
        <canvas id="gameCanvas"></canvas>

        <!-- This "Game Over" box is hidden at first. Our JavaScript will make it appear when the game ends. -->
        <div id="gameOverMessage" class="hidden">
            <h2 class="text-2xl sm:text-3xl mb-3 text-red-500">BUSTED!</h2>
            <p class="mb-1">Your Score: <span id="finalScore">0</span></p>
            <p class="mb-4">High Score: <span id="finalHighScore">0</span></p>
            <button id="restartButton" class="game-button">Play Again</button>
        </div>
    </div>

    <!-- This box holds our "Start Game" button. -->
    <div class="button-container">
        <button id="startButton" class="game-button">Start Game</button>
    </div>

    <!-- And this box holds our touch buttons for phones. It's usually hidden. -->
    <div id="touchControls" class="mt-4">
        <button id="touchLeft" class="touch-button">LEFT</button>
        <button id="touchAccel" class="touch-button">ACCEL</button>
        <button id="touchDecel" class="touch-button">DECEL</button>
        <button id="touchRight" class="touch-button">RIGHT</button>
    </div>

    <!-- The <script> tag is where we put all our JavaScript code. -->
    <!-- This is the magic that makes the game actually run, move, and be fun! -->
    <script>
        // --- 1. INITIAL SETUP AND VARIABLE DECLARATIONS ---

        // Get references to all necessary HTML elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const highScoreDisplay = document.getElementById('highScore');
        const announcerTextElement = document.getElementById('announcerText');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const finalScoreDisplay = document.getElementById('finalScore');
        const finalHighScoreDisplay = document.getElementById('finalHighScore');
        const restartButton = document.getElementById('restartButton');
        const startButton = document.getElementById('startButton');
        const touchLeftButton = document.getElementById('touchLeft');
        const touchRightButton = document.getElementById('touchRight');
        const touchAccelButton = document.getElementById('touchAccel');
        const touchDecelButton = document.getElementById('touchDecel');

        // --- Game Constants ---
        let gameWidth = 320; // Base width of the playable road area
        let gameHeight = 480; // Base height of the playable road area
        const signAreaWidth = 120; // Additional width on the canvas for the signs

        // --- Player State Variables ---
        let playerCar; // Object to hold player car properties (x, y, width, height)
        const playerCarWidth = 35;
        const playerCarHeight = 60;
        const playerCarSideSpeed = 18; // How fast the car moves left and right

        // --- Obstacle State Variables ---
        let obstacles; // Array to hold all on-screen obstacles
        const baseObstacleWidth = 35;
        const baseObstacleHeightCar = 60;
        const baseObstacleHeightPit = 30;
        let obstacleSpawnInterval = 1500; // Time in milliseconds between new obstacles
        let lastObstacleSpawnTime = 0;

        // --- Road Drawing Variables ---
        let roadLines; // Array to hold the dashed lines on the road
        const roadLineWidth = 10;
        const roadLineHeight = 50;

        // --- Game State Variables ---
        let score = 0;
        // Load high score from the browser's local storage, or default to 0
        let highScore = localStorage.getItem('retroCarHighScoreV2') || 0;
        let gameRunning = false; // Flag to check if the game loop is active
        let animationFrameId; // ID for the requestAnimationFrame loop to be able to cancel it
        let gameTime = 0; // Counter to track elapsed time for difficulty scaling

        // --- Speed and Police Logic Variables ---
        let playerGear = 1;
        const maxGear = 5;
        const minGear = 1;
        let currentMPH = 0;
        const mphPerGear = 25;
        const speedLimitPolice = 80; // Speed at which police start chasing
        const speedLimitSignFlash = 120; // Speed at which the display flashes
        let policeCar = null; // Object to hold the police car if it's on screen
        let policeFlashTimer = 0; // Timer for the police car's flashing lights
        const policeFlashInterval = 15; // How many frames between light flashes
        let signFlashCounter = 0; // Counter for the speed sign's flashing text


        // --- 2. GEMINI API INTEGRATION ---

        /**
         * Asynchronously calls the Gemini API to get a dynamic commentary line from the announcer.
         * @param {string} situation - The key for the game event (e.g., 'game_start', 'police_chase').
         */
        async function callGeminiAnnouncer(situation) {
            // Show a loading indicator while fetching the comment
            announcerTextElement.textContent = "...";
            // The base prompt to set the persona of the LLM
            let prompt = "You are a cheesy, over-the-top 90s arcade car racing game announcer. Keep your commentary short, punchy, and exciting (max 15 words). ";

            // Add specific instructions based on the game situation
            switch (situation) {
                case 'game_start':
                    prompt += "The race is about to begin! Give an epic starting line.";
                    break;
                case 'police_chase':
                    prompt += "The police are now chasing the player! What's your call?";
                    break;
                case 'crash_obstacle':
                    prompt += "The player just crashed into an obstacle! Give a dramatic game over line.";
                    break;
                case 'busted_police':
                    prompt += "The player got busted by the police! What's the verdict, announcer?";
                    break;
                case 'new_high_score':
                    prompt += `The player just got a new high score of ${highScore}! Announce this amazing achievement!`;
                    break;
                case 'speed_warning':
                    prompt += `The player is speeding over ${speedLimitPolice} MPH! Give a quick, excited warning!`;
                    break;
                default:
                    announcerTextElement.textContent = "Let's Race!";
                    return;
            }

            // Prepare the payload for the Gemini API
            const payload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }]
            };
            const apiKey = ""; // This will be provided by the Canvas environment automatically
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                // Make the API call using the fetch() function
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }
                const result = await response.json();

                // Check if the response is valid and extract the text
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    announcerTextElement.textContent = result.candidates[0].content.parts[0].text;
                } else {
                    console.warn("Gemini API response structure unexpected or content missing.", result);
                    announcerTextElement.textContent = "Mic check...1...2...";
                }
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                announcerTextElement.textContent = "Announcer's on a break!";
            }
        }


        // --- 3. HELPER AND UTILITY FUNCTIONS ---

        /**
         * Draws a rectangle with rounded corners on the canvas. A common utility for UI elements.
         * @param {number} x - The x-coordinate of the rectangle's top-left corner.
         * @param {number} y - The y-coordinate of the rectangle's top-left corner.
         * @param {number} width - The width of the rectangle.
         * @param {number} height - The height of the rectangle.
         * @param {number} radius - The corner radius.
         * @param {string} fillStyle - The color to fill the rectangle.
         * @param {string} [strokeStyle=null] - The color for the rectangle's border.
         * @param {number} [lineWidth=1] - The width of the border.
         */
        function drawRoundedRect(x, y, width, height, radius, fillStyle, strokeStyle = null, lineWidth = 1) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();

            if (fillStyle) {
                ctx.fillStyle = fillStyle;
                ctx.fill();
            }
            if (strokeStyle) {
                ctx.strokeStyle = strokeStyle;
                ctx.lineWidth = lineWidth;
                ctx.stroke();
            }
        }


        // --- 4. CORE GAME LOGIC ---

        /**
         * Initializes or re-initializes all game state variables and sets up the canvas for a new game.
         */
        function initGame() {
            // Get the container element to determine responsive size
            const container = document.getElementById('gameContainer');
            // Define the total aspect ratio including the side area for signs
            const totalGameWidthWithSign = gameWidth + signAreaWidth;
            const aspectRatio = totalGameWidthWithSign / gameHeight;

            // Calculate new canvas dimensions to fit the window while maintaining aspect ratio
            let newWidth = Math.min(window.innerWidth * 0.95, 700);
            let newHeight = newWidth / aspectRatio;

            if (newHeight > window.innerHeight * 0.70) {
                newHeight = window.innerHeight * 0.70;
                newWidth = newHeight * aspectRatio;
            }

            canvas.width = newWidth;
            canvas.height = newHeight;

            // Calculate a scaling factor based on the original base width and the new responsive width
            const scaleFactor = (canvas.width * (gameWidth / totalGameWidthWithSign)) / gameWidth;

            // Reset player car to its starting position
            playerCar = {
                x: (canvas.width * (gameWidth / totalGameWidthWithSign)) / 2 - (playerCarWidth * scaleFactor) / 2,
                y: canvas.height - (playerCarHeight * scaleFactor) - 15 * scaleFactor,
                width: playerCarWidth * scaleFactor,
                height: playerCarHeight * scaleFactor,
                color: '#FF0000',
            };

            // Reset all game state variables
            obstacles = [];
            roadLines = [];
            score = 0;
            gameTime = 0;
            playerGear = 1;
            updateSpeed();
            lastObstacleSpawnTime = 0;
            policeCar = null;

            // Update UI displays
            scoreDisplay.textContent = score;
            highScoreDisplay.textContent = highScore;
            gameOverMessage.classList.add('hidden'); // Hide the game over message
            gameRunning = true; // Set the game to active

            // Pre-populate the road lines array for a seamless start
            const roadAreaWidth = canvas.width * (gameWidth / totalGameWidthWithSign);
            for (let i = 0; i < Math.ceil(canvas.height / (roadLineHeight * scaleFactor + 20 * scaleFactor)) + 1; i++) {
                roadLines.push({
                    x: roadAreaWidth / 2 - (roadLineWidth * scaleFactor) / 2,
                    y: i * (roadLineHeight * scaleFactor + 20 * scaleFactor),
                    width: roadLineWidth * scaleFactor,
                    height: roadLineHeight * scaleFactor
                });
            }

            // Get an announcer line for the start of the game
            callGeminiAnnouncer('game_start');
            // Start the main game loop
            loop();
        }

        /**
         * Starts the game when the start button is clicked.
         */
        function startGame() {
            startButton.classList.add('hidden');
            initGame();
        }

        /**
         * Resets the game to the initial screen after a game over.
         */
        function restartGame() {
            gameOverMessage.classList.add('hidden');
            startButton.classList.remove('hidden');
            announcerTextElement.textContent = "Press Start to Race!";
        }

        /**
         * Updates the current speed based on the player's gear and checks for police pursuit conditions.
         */
        function updateSpeed() {
            const oldMPH = currentMPH;
            currentMPH = playerGear * mphPerGear;
            // If player crosses the speed limit for the first time, spawn police
            if (currentMPH >= speedLimitPolice && oldMPH < speedLimitPolice && !policeCar && gameRunning) {
                spawnPoliceCar();
            } else if (currentMPH > speedLimitPolice && oldMPH <= speedLimitPolice && gameRunning && !policeCar) {
                callGeminiAnnouncer('speed_warning');
            }
        }

        /**
         * The main game loop, called for every frame of animation.
         * @param {number} currentTime - The timestamp provided by requestAnimationFrame.
         */
        function loop(currentTime) {
            if (!gameRunning) return; // Stop the loop if the game is over

            update(currentTime); // Update all game logic
            draw(); // Redraw everything on the canvas

            // Request the next frame, creating the animation loop
            animationFrameId = requestAnimationFrame(loop);
        }

        /**
         * Updates all game logic for a single frame.
         * @param {number} currentTime - The current timestamp.
         */
        function update(currentTime) {
            gameTime += 16; // Approximately 16ms per frame
            const roadAreaWidth = canvas.width * (gameWidth / (gameWidth + signAreaWidth));
            const scaleFactor = roadAreaWidth / gameWidth;
            const currentBaseScrollSpeed = playerGear * 1.5 * scaleFactor;

            // Move the dashed road lines downwards
            roadLines.forEach(line => {
                line.y += currentBaseScrollSpeed;
                if (line.y > canvas.height) {
                    line.y = -(line.height + 10 * scaleFactor); // Reset to the top
                }
            });

            // Check if it's time to spawn a new obstacle
            if (currentTime - lastObstacleSpawnTime > obstacleSpawnInterval) {
                spawnObstacle();
                lastObstacleSpawnTime = currentTime;
            }

            // Loop through obstacles backwards (to allow safe removal from array)
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                // Cars move relative to player speed, pits move with the road
                if (obs.type === 'car') {
                    obs.y += currentBaseScrollSpeed + obs.relativeSpeed * scaleFactor;
                } else {
                    obs.y += currentBaseScrollSpeed;
                }

                // Check for collision with the player car
                if (checkCollision(playerCar, obs)) {
                    gameOver("CRASHED!", 'crash_obstacle');
                    return;
                }

                // Remove obstacles that have moved off the bottom of the screen
                if (obs.y > canvas.height) {
                    obstacles.splice(i, 1);
                    if (obs.type !== 'pit') { // Don't score for passing pits
                        score++;
                        scoreDisplay.textContent = score;
                    }
                }
            }

            // Update police car logic if it exists
            if (policeCar) {
                policeCar.y += (currentBaseScrollSpeed + policeCar.relativeSpeed * scaleFactor);
                // Police car tries to align horizontally with the player
                if (policeCar.x < playerCar.x - policeCar.width / 3) policeCar.x += 1.5 * scaleFactor;
                if (policeCar.x > playerCar.x + playerCar.width / 3) policeCar.x -= 1.5 * scaleFactor;

                // Check for collision with the police car
                if (checkCollision(playerCar, policeCar)) {
                    gameOver("BUSTED BY POLICE!", 'busted_police');
                    return;
                }
                // Remove police car if it drives past
                if (policeCar.y > canvas.height + policeCar.height) {
                    policeCar = null;
                }
                // Update the timer for the flashing lights
                policeFlashTimer = (policeFlashTimer + 1) % (policeFlashInterval * 2);
            }

            // Increase difficulty over time by decreasing the obstacle spawn interval
            if (gameTime > 0 && gameTime % 10000 < 16) {
                obstacleSpawnInterval = Math.max(500, obstacleSpawnInterval * 0.90);
            }
            signFlashCounter++; // Increment counter for sign flashing animation
        }

        /**
         * Checks for AABB (Axis-Aligned Bounding Box) collision between two rectangular objects.
         * @param {object} rect1 - The first object with x, y, width, height properties.
         * @param {object} rect2 - The second object with x, y, width, height properties.
         * @returns {boolean} - True if the rectangles are colliding, false otherwise.
         */
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y;
        }

        // --- 5. DRAWING AND RENDERING ---

        /**
         * Draws all game elements onto the canvas for a single frame.
         */
        function draw() {
            const roadAreaWidth = canvas.width * (gameWidth / (gameWidth + signAreaWidth));
            const scaleFactor = roadAreaWidth / gameWidth;

            // Clear the entire canvas with a background color
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw the main road area
            ctx.fillStyle = '#4a4a4a';
            ctx.fillRect(0, 0, roadAreaWidth, canvas.height);

            // Draw road shoulders and grass verges
            const shoulderWidth = 30 * scaleFactor;
            ctx.fillStyle = '#303030';
            ctx.fillRect(0, 0, shoulderWidth, canvas.height);
            ctx.fillRect(roadAreaWidth - shoulderWidth, 0, shoulderWidth, canvas.height);

            const grassWidth = 25 * scaleFactor;
            ctx.fillStyle = '#004d00';
            ctx.fillRect(0, 0, grassWidth, canvas.height);
            ctx.fillRect(roadAreaWidth - grassWidth, 0, grassWidth, canvas.height);

            // Draw the dashed road lines
            ctx.fillStyle = '#cccccc';
            roadLines.forEach(line => {
                ctx.fillRect(line.x, line.y, line.width, line.height);
            });

            // Draw the player's car with simple details
            ctx.fillStyle = playerCar.color;
            ctx.fillRect(playerCar.x, playerCar.y, playerCar.width, playerCar.height);
            ctx.fillStyle = 'rgba(0,0,0,0.3)'; // Windshield
            ctx.fillRect(playerCar.x + playerCar.width * 0.15, playerCar.y + playerCar.height * 0.1, playerCar.width * 0.7, playerCar.height * 0.25);
            ctx.fillStyle = '#333333'; // Wheels
            ctx.fillRect(playerCar.x - 3 * scaleFactor, playerCar.y + playerCar.height * 0.2, 3 * scaleFactor, playerCar.height * 0.6);
            ctx.fillRect(playerCar.x + playerCar.width, playerCar.y + playerCar.height * 0.2, 3 * scaleFactor, playerCar.height * 0.6);

            // Draw all obstacles
            obstacles.forEach(obs => {
                ctx.fillStyle = obs.color;
                if (obs.type === 'pit') {
                    // Draw pits as ellipses
                    ctx.beginPath();
                    ctx.ellipse(obs.x + obs.width / 2, obs.y + obs.height / 2, obs.width / 2, obs.height / 2.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else { // Draw other cars
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                    ctx.fillStyle = 'rgba(0,0,0,0.4)'; // Windshield
                    ctx.fillRect(obs.x + obs.width * 0.15, obs.y + obs.height * 0.1, obs.width * 0.7, obs.height * 0.25);
                }
            });

            // Draw the police car and its flashing lights if it exists
            if (policeCar) {
                ctx.fillStyle = policeCar.color;
                ctx.fillRect(policeCar.x, policeCar.y, policeCar.width, policeCar.height);
                const lightWidth = policeCar.width * 0.25;
                const lightHeight = policeCar.height * 0.1;
                // Alternate red/blue lights based on the flash timer
                if (policeFlashTimer < policeFlashInterval) {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(policeCar.x + policeCar.width * 0.15, policeCar.y, lightWidth, lightHeight);
                    ctx.fillStyle = 'blue';
                    ctx.fillRect(policeCar.x + policeCar.width * 0.6, policeCar.y, lightWidth, lightHeight);
                } else {
                    ctx.fillStyle = 'blue';
                    ctx.fillRect(policeCar.x + policeCar.width * 0.15, policeCar.y, lightWidth, lightHeight);
                    ctx.fillStyle = 'red';
                    ctx.fillRect(policeCar.x + policeCar.width * 0.6, policeCar.y, lightWidth, lightHeight);
                }
            }

            // --- Draw Speed Sign UI on the right side of the canvas ---
            const signAreaX = roadAreaWidth;
            const signAreaActualWidth = canvas.width - roadAreaWidth;
            const signSizeReductionFactor = 0.8;

            // --- Main Speed Limit Sign ---
            let mainSignTextSize = 12 * scaleFactor * 1.4 * signSizeReductionFactor;
            let mainSignNumberSize = 28 * scaleFactor * 1.4 * signSizeReductionFactor;
            const mainSignCornerRadius = 6 * scaleFactor * signSizeReductionFactor;
            const mainSignPaddingX = 8 * scaleFactor * signSizeReductionFactor;
            const mainSignPaddingY = 6 * scaleFactor * signSizeReductionFactor;

            const line1Font = `bold ${mainSignTextSize}px 'Press Start 2P'`;
            const line3Font = `bold ${mainSignNumberSize}px 'Press Start 2P'`;

            // Measure text to dynamically calculate sign size
            ctx.font = line1Font;
            const speedTextWidth = ctx.measureText("SPEED").width;
            const limitTextWidth = ctx.measureText("LIMIT").width;
            ctx.font = line3Font;
            const numberTextWidth = ctx.measureText(speedLimitPolice.toString()).width;
            const maxMainTextWidth = Math.max(speedTextWidth, limitTextWidth, numberTextWidth);

            const mainSignFaceWidth = maxMainTextWidth + mainSignPaddingX * 2;
            const spacingBetweenLines = 4 * scaleFactor * signSizeReductionFactor;
            const explicitGap = 12 * scaleFactor * signSizeReductionFactor; // Increased gap

            const mainSignFaceHeight = (mainSignPaddingY * 2) + mainSignTextSize + spacingBetweenLines + mainSignTextSize + explicitGap + mainSignNumberSize;

            const mainSignFaceX = signAreaX + (signAreaActualWidth - mainSignFaceWidth) / 2;
            const mainSignFaceY = canvas.height * 0.05 + (canvas.height * 0.45 - (mainSignFaceHeight * 2 + 10 * scaleFactor * signSizeReductionFactor)) / 2;

            drawRoundedRect(mainSignFaceX, mainSignFaceY, mainSignFaceWidth, mainSignFaceHeight, mainSignCornerRadius, '#FFFFFF', '#000000', 2 * scaleFactor * signSizeReductionFactor);

            ctx.fillStyle = '#000000';
            ctx.textAlign = 'center';

            let currentBaselineY = mainSignFaceY + mainSignPaddingY + mainSignTextSize;
            ctx.font = line1Font;
            ctx.fillText("SPEED", mainSignFaceX + mainSignFaceWidth / 2, currentBaselineY);

            currentBaselineY += mainSignTextSize + spacingBetweenLines;
            ctx.font = line1Font;
            ctx.fillText("LIMIT", mainSignFaceX + mainSignFaceWidth / 2, currentBaselineY);

            currentBaselineY += mainSignTextSize + explicitGap;
            ctx.font = line3Font;
            ctx.fillText(speedLimitPolice.toString(), mainSignFaceX + mainSignFaceWidth / 2, currentBaselineY);


            // --- "Your Speed" Sign ---
            const yourSpeedSignFaceWidth = mainSignFaceWidth;
            const yourSpeedSignFaceHeight = mainSignFaceHeight;
            const yourSpeedSignCornerRadius = mainSignCornerRadius;

            const yourSpeedSignFaceX = mainSignFaceX;
            const yourSpeedSignFaceY = mainSignFaceY + mainSignFaceHeight + 10 * scaleFactor * signSizeReductionFactor;

            let yourSpeedFillStyle = '#000000';
            let yourSpeedStrokeStyle = '#FFFFFF';
            let yourSpeedLabelColor = '#FFFFFF';
            let currentSpeedNumberColor = '#FFFFFF';

            if (currentMPH >= speedLimitSignFlash) {
                if (signFlashCounter % 20 < 10) {
                    currentSpeedNumberColor = 'red';
                } else {
                    currentSpeedNumberColor = 'white';
                }
            }
            drawRoundedRect(yourSpeedSignFaceX, yourSpeedSignFaceY, yourSpeedSignFaceWidth, yourSpeedSignFaceHeight, yourSpeedSignCornerRadius, yourSpeedFillStyle, yourSpeedStrokeStyle, 1.5 * scaleFactor * signSizeReductionFactor);

            let yourSpeedLine1FontSize = mainSignTextSize;
            let yourSpeedLine3FontSize = mainSignNumberSize;

            const yourSpeedLine1Font = `bold ${yourSpeedLine1FontSize}px 'Press Start 2P'`;
            const yourSpeedLine3Font = `bold ${yourSpeedLine3FontSize}px 'Press Start 2P'`;


            let currentYourSpeedBaselineY = yourSpeedSignFaceY + mainSignPaddingY + yourSpeedLine1FontSize;
            ctx.font = yourSpeedLine1Font;
            ctx.fillStyle = yourSpeedLabelColor;
            ctx.fillText('YOUR', yourSpeedSignFaceX + yourSpeedSignFaceWidth / 2, currentYourSpeedBaselineY);

            currentYourSpeedBaselineY += yourSpeedLine1FontSize + spacingBetweenLines;
            ctx.font = yourSpeedLine1Font;
            ctx.fillText('SPEED', yourSpeedSignFaceX + yourSpeedSignFaceWidth / 2, currentYourSpeedBaselineY);

            currentYourSpeedBaselineY += yourSpeedLine1FontSize + explicitGap;
            ctx.fillStyle = currentSpeedNumberColor;
            ctx.font = yourSpeedLine3Font;
            ctx.fillText(currentMPH.toString(), yourSpeedSignFaceX + yourSpeedSignFaceWidth / 2, currentYourSpeedBaselineY);
        }

        // --- 6. OBSTACLE AND ENTITY SPAWNING ---

        /**
         * Creates a new obstacle (either a car or a pit) and adds it to the obstacles array.
         */
        function spawnObstacle() {
            const roadAreaWidth = canvas.width * (gameWidth / (gameWidth + signAreaWidth));
            const scaleFactor = roadAreaWidth / gameWidth;
            const type = Math.random() < 0.35 ? 'pit' : 'car'; // 35% chance for a pit

            const shoulderAndGrassWidth = (30 + 25) * scaleFactor;
            let obsWidth, obsHeight, color, relativeSpeed = 0;

            if (type === 'pit') {
                obsWidth = (baseObstacleWidth + Math.random() * 15) * scaleFactor;
                obsHeight = baseObstacleHeightPit * scaleFactor * (Math.random() * 0.5 + 0.8);
                color = '#101010';
            } else { // Car
                obsWidth = baseObstacleWidth * scaleFactor * (Math.random() * 0.2 + 0.9);
                obsHeight = baseObstacleHeightCar * scaleFactor * (Math.random() * 0.2 + 0.9);
                const carColors = ['#00BFFF', '#FFD700', '#32CD32', '#FF69B4', '#9370DB', '#FFA500', '#8A2BE2'];
                color = carColors[Math.floor(Math.random() * carColors.length)];
                relativeSpeed = (Math.random() * 2.0 + 0.5) * (currentMPH / 50 + 0.5);
            }

            const minX = shoulderAndGrassWidth;
            const maxX = roadAreaWidth - shoulderAndGrassWidth - obsWidth;
            if (maxX <= minX) {
                console.warn("Road too narrow for obstacle spawn, skipping.");
                return;
            }
            const x = Math.random() * (maxX - minX) + minX;
            const y = -obsHeight; // Spawn above the screen

            obstacles.push({ x, y, width: obsWidth, height: obsHeight, color, type, relativeSpeed });
        }

        /**
         * Creates a new police car and gets a comment from the announcer.
         */
        function spawnPoliceCar() {
            if (policeCar) return; // Only one police car at a time
            const roadAreaWidth = canvas.width * (gameWidth / (gameWidth + signAreaWidth));
            const scaleFactor = roadAreaWidth / gameWidth;
            const policeCarWidthScaled = playerCarWidth * 1.1 * scaleFactor;
            const policeCarHeightScaled = playerCarHeight * 1.1 * scaleFactor;

            const shoulderAndGrassWidth = (30 + 25) * scaleFactor;
            const minX = shoulderAndGrassWidth;
            const maxX = roadAreaWidth - shoulderAndGrassWidth - policeCarWidthScaled;

            policeCar = {
                x: playerCar.x,
                y: -policeCarHeightScaled * 3, // Start further back off-screen
                width: policeCarWidthScaled,
                height: policeCarHeightScaled,
                color: '#00008B', // Dark Blue
                relativeSpeed: 3.0 + Math.random() * 0.5 + (currentMPH / 100),
                type: 'police'
            };
            callGeminiAnnouncer('police_chase');
        }

        // --- 7. GAME OVER AND EVENT HANDLING ---

        /**
         * Ends the game, updates high scores, and displays the game over message.
         * @param {string} message - The message to display on the game over screen (e.g., "CRASHED!").
         * @param {string} announcerKey - The key for the Gemini announcer for this specific game over reason.
         */
        async function gameOver(message = "GAME OVER!", announcerKey = 'crash_obstacle') {
            gameRunning = false;
            cancelAnimationFrame(animationFrameId); // Stop the game loop
            const isNewHighScore = score > highScore;
            if (isNewHighScore) {
                highScore = score;
                localStorage.setItem('retroCarHighScoreV2', highScore);
                callGeminiAnnouncer('new_high_score');
            } else {
                callGeminiAnnouncer(announcerKey);
            }

            finalScoreDisplay.textContent = score;
            finalHighScoreDisplay.textContent = highScore;
            highScoreDisplay.textContent = highScore;
            gameOverMessage.querySelector('h2').textContent = message;
            gameOverMessage.classList.remove('hidden'); // Show the message
            startButton.classList.remove('hidden');
        }

        // --- Event Listeners for Keyboard and Touch Input ---

        /**
         * Handles keyboard input for player controls.
         * @param {KeyboardEvent} e - The keyboard event object.
         */
        function handleKeyDown(e) {
            if (!gameRunning) return; // Ignore input if game isn't running

            const roadAreaWidth = canvas.width * (gameWidth / (gameWidth + signAreaWidth));
            const scaleFactor = roadAreaWidth / gameWidth;
            const effectiveSideSpeed = playerCarSideSpeed * scaleFactor;
            const drivableMinX = (30 + 25) * scaleFactor;
            const drivableMaxX = roadAreaWidth - playerCar.width - drivableMinX;

            if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
                playerCar.x = Math.max(drivableMinX, playerCar.x - effectiveSideSpeed);
            } else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                playerCar.x = Math.min(drivableMaxX, playerCar.x + effectiveSideSpeed);
            } else if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') {
                playerGear = Math.min(maxGear, playerGear + 1);
                updateSpeed();
            } else if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') {
                playerGear = Math.max(minGear, playerGear - 1);
                updateSpeed();
            }
        }

        /**
         * Handles touch input from on-screen buttons for player controls.
         * @param {string} action - The action to perform ('left', 'right', 'accel', 'decel').
         */
        function handleTouch(action) {
            if (!gameRunning) return;
            const roadAreaWidth = canvas.width * (gameWidth / (gameWidth + signAreaWidth));
            const scaleFactor = roadAreaWidth / gameWidth;
            const effectiveSideSpeed = playerCarSideSpeed * scaleFactor * 1.2;
            const drivableMinX = (30 + 25) * scaleFactor;
            const drivableMaxX = roadAreaWidth - playerCar.width - drivableMinX;

            if (action === 'left') {
                playerCar.x = Math.max(drivableMinX, playerCar.x - effectiveSideSpeed);
            } else if (action === 'right') {
                playerCar.x = Math.min(drivableMaxX, playerCar.x + effectiveSideSpeed);
            } else if (action === 'accel') {
                playerGear = Math.min(maxGear, playerGear + 1);
                updateSpeed();
            } else if (action === 'decel') {
                playerGear = Math.max(minGear, playerGear - 1);
                updateSpeed();
            }
        }

        // Attach all event listeners
        window.addEventListener('keydown', handleKeyDown);
        restartButton.addEventListener('click', restartGame);
        startButton.addEventListener('click', startGame);
        touchLeftButton.addEventListener('touchstart', (e) => { e.preventDefault(); handleTouch('left'); });
        touchRightButton.addEventListener('touchstart', (e) => { e.preventDefault(); handleTouch('right'); });
        touchAccelButton.addEventListener('touchstart', (e) => { e.preventDefault(); handleTouch('accel'); });
        touchDecelButton.addEventListener('touchstart', (e) => { e.preventDefault(); handleTouch('decel'); });

        /**
         * Checks if the device is a touch-enabled device.
         * @returns {boolean} - True if touch is supported.
         */
        function isTouchDevice() {
            return ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        }

        // Show touch controls only on touch-enabled devices
        if (isTouchDevice()) {
            document.getElementById('touchControls').style.display = 'flex';
        }

        // Listen for window resize events to make the game responsive
        window.addEventListener('resize', () => {
            const gameWasRunning = gameRunning;
            if (gameRunning) {
                cancelAnimationFrame(animationFrameId);
                gameRunning = false;
            }

            // Recalculate canvas dimensions on resize
            const totalGameWidthWithSign = gameWidth + signAreaWidth;
            const aspectRatio = totalGameWidthWithSign / gameHeight;
            let newWidth = Math.min(window.innerWidth * 0.95, 700);
            let newHeight = newWidth / aspectRatio;
            if (newHeight > window.innerHeight * 0.70) {
                newHeight = window.innerHeight * 0.70;
                newWidth = newHeight * aspectRatio;
            }
            canvas.width = newWidth;
            canvas.height = newHeight;

            // Re-initialize the game if it was running, otherwise just redraw the static screen
            if (gameWasRunning) {
                initGame();
            } else {
                drawPlaceholderScreen();
            }
        });

        /**
         * Draws the initial static screen before the game starts.
         */
        function drawPlaceholderScreen() {
            const roadAreaWidth = canvas.width * (gameWidth / (gameWidth + signAreaWidth));
            const scaleFactor = roadAreaWidth / gameWidth;

            // Draw background and road elements
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#4a4a4a';
            ctx.fillRect(0, 0, roadAreaWidth, canvas.height);
            const shoulderWidth = 30 * scaleFactor;
            ctx.fillStyle = '#303030';
            ctx.fillRect(0, 0, shoulderWidth, canvas.height);
            ctx.fillRect(roadAreaWidth - shoulderWidth, 0, shoulderWidth, canvas.height);
            const grassWidth = 25 * scaleFactor;
            ctx.fillStyle = '#004d00';
            ctx.fillRect(0, 0, grassWidth, canvas.height);
            ctx.fillRect(roadAreaWidth - grassWidth, 0, grassWidth, canvas.height);
            ctx.fillStyle = '#cccccc';
            for (let i = 0; i < Math.ceil(canvas.height / (roadLineHeight * scaleFactor + 20 * scaleFactor)) + 1; i++) {
                ctx.fillRect(roadAreaWidth / 2 - (roadLineWidth * scaleFactor) / 2, i * (roadLineHeight * scaleFactor + 20 * scaleFactor), roadLineWidth * scaleFactor, roadLineHeight * scaleFactor);
            }

            // Draw stylized "START GAME" text with 3D effect
            const baseStartGameFontSize = 22 * scaleFactor;
            const startGameFontSize = baseStartGameFontSize * 2;
            const shadowOffsetMain = 4 * scaleFactor;
            const shadowColorDarker = "#200060";
            const shadowColorDark = "#400090";
            const mainTextColor = "#FF40C0";

            ctx.textAlign = 'center';
            ctx.font = `bold ${startGameFontSize}px 'Press Start 2P'`;
            const textStartY = canvas.height / 2 - startGameFontSize * 0.6;
            const lineOffset = startGameFontSize * 1.2;

            ctx.fillStyle = shadowColorDarker;
            ctx.fillText('START', roadAreaWidth / 2 + shadowOffsetMain, textStartY + shadowOffsetMain);
            ctx.fillStyle = shadowColorDark;
            ctx.fillText('START', roadAreaWidth / 2 + shadowOffsetMain / 2, textStartY + shadowOffsetMain / 2);
            ctx.fillStyle = mainTextColor;
            ctx.fillText('START', roadAreaWidth / 2, textStartY);
            ctx.fillStyle = shadowColorDarker;
            ctx.fillText('GAME', roadAreaWidth / 2 + shadowOffsetMain, textStartY + lineOffset + shadowOffsetMain);
            ctx.fillStyle = shadowColorDark;
            ctx.fillText('GAME', roadAreaWidth / 2 + shadowOffsetMain / 2, textStartY + lineOffset + shadowOffsetMain / 2);
            ctx.fillStyle = mainTextColor;
            ctx.fillText('GAME', roadAreaWidth / 2, textStartY + lineOffset);

            // Draw static placeholder for the road signs
            const signAreaX = roadAreaWidth;
            const signAreaActualWidth = canvas.width - roadAreaWidth;
            const signSizeReductionFactor = 0.8;

            let mainSignTextSize = 12 * scaleFactor * 1.4 * signSizeReductionFactor;
            let mainSignNumberSize = 28 * scaleFactor * 1.4 * signSizeReductionFactor;
            const mainSignCornerRadius = 6 * scaleFactor * signSizeReductionFactor;
            const mainSignPaddingX = 8 * scaleFactor * signSizeReductionFactor;
            const mainSignPaddingY = 6 * scaleFactor * signSizeReductionFactor;

            ctx.font = `bold ${mainSignTextSize}px 'Press Start 2P'`;
            const speedTextWidth = ctx.measureText("SPEED").width;
            const limitTextWidth = ctx.measureText("LIMIT").width;
            ctx.font = `bold ${mainSignNumberSize}px 'Press Start 2P'`;
            const numberTextWidth = ctx.measureText(speedLimitPolice.toString()).width;
            const maxMainTextWidth = Math.max(speedTextWidth, limitTextWidth, numberTextWidth);
            const mainSignFaceWidth = maxMainTextWidth + mainSignPaddingX * 2;
            const spacingBetweenLines = 4 * scaleFactor * signSizeReductionFactor;
            const explicitGap = 12 * scaleFactor * signSizeReductionFactor; // Increased gap for placeholder
            const mainSignFaceHeight = (mainSignPaddingY * 2) + mainSignTextSize + spacingBetweenLines + mainSignTextSize + explicitGap + mainSignNumberSize;

            const mainSignFaceX = signAreaX + (signAreaActualWidth - mainSignFaceWidth) / 2;
            const mainSignFaceY = canvas.height * 0.05 + (canvas.height * 0.45 - (mainSignFaceHeight * 2 + 10 * scaleFactor * signSizeReductionFactor)) / 2;
            drawRoundedRect(mainSignFaceX, mainSignFaceY, mainSignFaceWidth, mainSignFaceHeight, mainSignCornerRadius, '#FFFFFF', '#000000', 2 * scaleFactor * signSizeReductionFactor);

            ctx.fillStyle = '#000000';
            ctx.textAlign = 'center';
            let currentBaselineY = mainSignFaceY + mainSignPaddingY + mainSignTextSize;
            ctx.font = `bold ${mainSignTextSize}px 'Press Start 2P'`;
            ctx.fillText('SPEED', mainSignFaceX + mainSignFaceWidth / 2, currentBaselineY);
            currentBaselineY += mainSignTextSize + spacingBetweenLines;
            ctx.fillText('LIMIT', mainSignFaceX + mainSignFaceWidth / 2, currentBaselineY);
            currentBaselineY += mainSignTextSize + explicitGap;
            ctx.font = `bold ${mainSignNumberSize}px 'Press Start 2P'`;
            ctx.fillText(speedLimitPolice.toString(), mainSignFaceX + mainSignFaceWidth / 2, currentBaselineY);

            const yourSpeedSignFaceWidth = mainSignFaceWidth;
            const yourSpeedSignFaceHeight = mainSignFaceHeight;
            const yourSpeedSignCornerRadius = mainSignCornerRadius;
            const yourSpeedSignFaceX = mainSignFaceX;
            const yourSpeedSignFaceY = mainSignFaceY + mainSignFaceHeight + 10 * scaleFactor * signSizeReductionFactor;
            drawRoundedRect(yourSpeedSignFaceX, yourSpeedSignFaceY, yourSpeedSignFaceWidth, yourSpeedSignFaceHeight, yourSpeedSignCornerRadius, '#000000', '#FFFFFF', 1.5 * scaleFactor * signSizeReductionFactor);

            let yourSpeedTextSize = mainSignTextSize;
            let yourSpeedNumberSize = mainSignNumberSize;

            currentBaselineY = yourSpeedSignFaceY + mainSignPaddingY + yourSpeedTextSize;
            ctx.fillStyle = '#FFFFFF';
            ctx.font = `bold ${yourSpeedTextSize}px 'Press Start 2P'`;
            ctx.fillText('YOUR', yourSpeedSignFaceX + yourSpeedSignFaceWidth / 2, currentBaselineY);
            currentBaselineY += yourSpeedTextSize + spacingBetweenLines;
            ctx.fillText('SPEED', yourSpeedSignFaceX + yourSpeedSignFaceWidth / 2, currentBaselineY);
            currentBaselineY += yourSpeedTextSize + explicitGap;
            ctx.font = `bold ${yourSpeedNumberSize}px 'Press Start 2P'`;
            ctx.fillText("0", yourSpeedSignFaceX + yourSpeedSignFaceWidth / 2, currentBaselineY);
        }

        // --- 8. INITIAL SCRIPT EXECUTION ---

        // Display the high score on page load
        highScoreDisplay.textContent = highScore;

        // Set the initial size of the canvas before the game starts
        const totalGameWidthWithSign = gameWidth + signAreaWidth;
        const aspectRatio = totalGameWidthWithSign / gameHeight;
        let initialWidth = Math.min(window.innerWidth * 0.95, 700);
        let initialHeight = initialWidth / aspectRatio;
        if (initialHeight > window.innerHeight * 0.70) {
            initialHeight = window.innerHeight * 0.70;
            initialWidth = initialHeight * aspectRatio;
        }
        canvas.width = initialWidth;
        canvas.height = initialHeight;

        // Draw the initial placeholder screen
        drawPlaceholderScreen();

    </script>
</body>

</html>